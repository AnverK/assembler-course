# Режимы работы процессора

## Real mod
- 16 битный процессор
    - У него могло быть 1 мб оперативки( с помощью регистров)
    - Адрес всегда состоит из seg:off
        - сегмент может вычисляться автоматически из регистра сегмента
            - cs (code), ds (data), ss(stack), es(extra).
            - fs, gs -- добавились позже (в 286)
    - 286 процессор вычислял физ. адрес = seg * 16 + off
        - Это было сделано, чтобы используя 16битные регистры можно использовать для 20битных адресов.
        - В "C" есть поэтому поводу оговорка, что объект не может занимать больше места чем максимальный размер смещения. (< 64kb)
        - Есть много способов сослаться на один адрес
        - Что будет если мы вывезем из диапазона? (мы можем выйти на 65519)
            - Как это работает? Проц. просто берет первые 20 бит.
            - Bios Line 20 disable -- опция биоса, которая позволяет включить эту фичу, для обратной совместимости.
- **Проблема: безопасность**
    - Любая программа имеет доступ ко всему. Поэтому появился защищенный режим работы

## Защищенный режим
Начиная с 286 было выделено 4 кольца.
- 0 - макс. права
- 3 - мин. права

На что влияют права?
- Как можно менять права.
- Что можно читать из оперативки.

Теперь сегментный регистр -- это что-то из 3 частей

0-1| 2  | 3-15
---|----|-----
RPL|G/L |index

- index -- индекс дескриптора сегмента
- g/l -- global/local description table, но локальные не используется.
    - gdtr -- регистр, который указывает на адрес таблицы.
- rpl -- права

Сегмент теперь устроен сложнее, вся информация написана в дескрипторе
- База сегмента (то, что было раньше в регистре сегмента)

Сегментный регистр имеет теневую часть, куда он загружает сегментный дескриптор.

внутри cs, rpl -- называется CPL -- current privilege level
Мы можем понизить свои права.
Но как повысить? Мы можем вызвать прерывание, у которого может быть выше уровень привилегий. И он может вернуть нам права.

**NB)** не путать сегмент с секцией. Секция -- это уровень операционной системы.

- В 32bit
    - Здесь у нас, так называемая Flat-module памяти. Когда у нас все базы сегментов равны 0 и лимит 4Kb

Переходы:
- Ближние jump, call -- в приделах одного сегмента памяти.
- Дальние: far_jump, far_call -- меняет также сегмент.

**Зачем сегменты**
    - Управление правами

**Как определяются права?**
- CPL
- RPL
- права, которые написаны в дескрипторе.

**Как написать обращение с указанием сегмента?**
```
mov al, [ebx] ; по-умолчанию

mov al, ds:[ebx]

ds: / seg ds
mov al, [ebx]
```
**по-умолчанию:**
- если мы обращаемся к стеку, то там ss по-умолчанию
- для команд аналогично cs
- для памяти: bp, ebp, esp => ss (sp нет, потому, что его не бывает в кв. скобках.)
- В некоторых командах есть свои умолчания. Например, movvc
- Остальные к ds

**Замечание**
```
mov al, [ebx + ebp] ; implementation undefined behavior

mov al, [ebx + ebp*1] ; хороший компилятор (not nasm) позволяет таким образом, подавить использование ebp как базы
```

## 32bit защищенный режим
Выбор режима зависит от размера загруженного дескриптора CS.

В 32bit мы не можем использовать ax, он интерпретируется как eax.

**Теневая часть сегментного регистра не меняется при изменении режима.**
Поэтому существует нереальный режим работы.

**Кто пишет под реальный режим?**
Почти никто, но биос работает в реальном режиме. И с этим приходить считаться.

## v86
**Подрежим защищенного**
Который адресуется как в реальном режиме. Но с правами 3 кольца.

| | | |
----------|---------|---------------|
reset     |         |  CR0.PE = 1   |
`------>` | real 16 | `<---------`  | protected 16/32, v86 16
          |         | `--------->`  |
          |         | CR0.PE = 0    |

## SMM
