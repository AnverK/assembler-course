# Конспект по курсу ассемблера.

## Используемые источники: 

- Лекции Скакова П. С.
- http://fat-crocodile.narod.ru
- https://www.felixcloutier.com/x86/

## Введение

`Ассемблер` -- это не язык программирования. Это мнемоника команд процессору. Из этого следует что, сколько существует ISA, токолько и различных ассемблеров.

В курсе рассматривается только архитектура x86, потому что она очень распространеная среди PC и появилась давольно давно, что позволяет ожидать хорошую совместимость программ написанных на ассемблере.

Сначала мы рассмотрим x86 (32bit), потом x64 (x86-64 bit)

### История процессоров

- i8086 (1978) -- 16bit
- i80186 (1982)
- i80286 (1982)
- i80386 (1985-1994) -- 32bit
- i80486 (1989-1994)
- Pentuim [Pro] (1993 [1995])
- Pentuim MMX (1997)
- Pentuim II (порезанный Pro) (1997)
- Pentuim III (1999)
- Pentuim M (2003) -- M=mobile
- Core 2 (2006) -- 64bit

NB) x86 - reg-mem2, cisc

### Полезные ссылки

[](www.agner.org) -- можно найти информацию о производительности на разных архитектурах.
[](www.aida64russia.com) -- инструмент для тестирования производительности.
[справка по командам](https://www.felixcloutier.com/x86/)

## Обзор регистров

eax = 32 bit = [16bit]:ax (ax -- младшие 16 бит от eax, только для e*x регистров)
ax = ah:al (только для *x)

NB) Иногда не совсем понятно, почему существуют некоторые ограничения и почему некоторые команды предпочтительнее других. Это чаще всего происходит из-за неодинакового размера кода команды, на котором пытаются сэкономить.

Регистры общего назначения (General Proposal)

- eax - accumulator
- ecx - counter
- edx - data
- ebx - base
- esi - source index
- edi - destination index
- esp - stack pointer
- ebp - base pointer

NB) регистры букв важен только в метках
NB) лучше всего использовать регистры той битности, что и режим процессора.

Также есть eip (instruction pointer) - в коде мы его не можем использовать. (`почти`)

EFLAGS - регистр, которые содержит различные флаги.
- ZF (zero flag) -- нулевой результат вычисления
- CF (carry flag) -- переполнение результата
- SF (sign flag) -- знак результата
- DF (direction flag) -- нужен для особых команд

## Обзор команд

### пересылка дынных

#### mov
```asm
mov eax, ebx
mov al, ah
mov ax, [ebx]
mov [eax _ ebx * 4], ebx
```
Что можно писать в скобках: 

- `[base_register32 + index_register32 * scale_factor + offset32]`
    - base_register32 = general proposal 32-bit register
    - index_register32 = gp 32-bit without `esp`
    - scale_factor = {1, 2, 4, 8}
- `[base_register16 + index_register16 + offset16]`
    - base_register16 = {bx, bp}
    - index_register16 = {si, di}



**Замечание:** Некоторые компиляторы, например yasm, позволяют в скобках писать `5*eax`. Они это просто сконвертируют, к верхней схеме, если смогут.

Также иногда необходимо указать размер пересылаемых данных [byte, word, dword]:
```asm
mov dword, [eax], 5
```

#### другие

- `xchg` -- "swap". Между регистрами почти бесплатный, а по памяти -- дорогая, так как является блокирующей.
- `bswap` -- меняет порядок байт (endion)
- `movsx/movzx` -- меньшее в большее, первая заполняет знаковым битом, а вторая 0.
- `lea` (load effective address) -- вычисляет адрес и записывает его в первые операнд.
- `push/pop` -- команды работы со стеком: положить и снять.
- `pushad/pusha` -- выгрузить все общие регистры на стек (8 штук); первая для 32битных, вторая -- для 16битных регистров. Порядок, как указано выше.
- `popad/popaa` -- снять все регистры со стека. Но esp не запишется.

### переходы

- `jmp` -- прыгает на указанный адрес, можно передавать регистр. (просто меняет `eip`)
- `call` -- вызывает функцию. То же самое, что `jmp ...`+ `push eip`.
- `ret/ret const` -- возврат из функции. То же самое, что `pop eip`. Вторая команда дополнительно снимает const байт со стека, т. е. то же что `pop eip` + `add esp, const`.
- `j__` -- условные переход на метку, в зависимости от состояние флагов. Нельзя передавать регистр. Работает предсказание переходов.
  - c/z/s -- если соответствующий флаг установлен: `je label`
  - a(e)/b(e) -- беззнаковое сравнение
  - g(e)/l(e) -- знаковое сравнение
- `cmov__` -- условная загрузка. Суффикс как выше. Не предсказывается.

### арифметика

Практически все арифметически операции меняют флаги.

- `add/adc` -- сложение/сложение + флаг переноса. (carry flag)
- `sub/sbb` -- вычитание/вычитание - флаг переноса.
- `mul rx` -- беззнаковое умножение.
  - `mul r8` => ah:al = ah * r8
  - `mul r16` => dx:ax = ax * r16
  - `mul r32` => edx:eax = eax * r32
- `imul` -- знаковое умножение
  - `imul reg` => как выше
  - `imul dst, src` => dst *= src
  - `imul dst, src, const` => dst = src * const
- `div/idiv arg32` => edx:eax = (edx:eax / arg32):(edx:eax % arg32) Если результат не влезет в eax будет ошибка переполнения.
- `cwd/cdq` -- делает регистровую пару edx:eax/dx:ax, заполняя знаковым битом.
- `inc/dec` -- инкремент/декремент. Не меняет флаги.
- `neg` - арифметическое отрицание.
- `and/or/xor/not` -- побитовые логические операции
 - `xor eax, eax` -- обнуление eax, это стандартный способ обнуления. Занимает меньше кода, но меняет флаги.
- `cmp/test` -- соответствует sub/and, но меняет только флаги. В сочетании с условными переходами позволяет делать условные конструкции.
  - `cmp/test` + `j__` -- часто это одна реальная команда, поэтому не нужно их лишний раз разделять.
  - `test eax, eax` -- стандартный способ проверки на 0.ч
- `shr/shl` -- логические сдивиги (заполнение нулям), sar/sal -- арифметические сдвиги (заполнение знаковым битом при правом сдвиге, левый сдвиг равен логическому.)
  - последний потерянный бит сохраняется в CF
  - при сдвиге на больше чем 32 **будет использоваться только 5 бит**
- `shld/shrd` -- сдвиги двойной точности. (Можно делить пару)
  - `shld reg1 reg2, const` -- сдвиг, но потерянные биты беруться из reg2
- `ror/rol` -- циклический сдвиг
- `rcr` -- циклический сдвиг следующей штуки: (..<-[cf]<-[31..0]<-..)
- `rcl` -- циклические сдвиг следующей штуки: (..->[31..0]->[cf]->..)

### другое

- `int{x}` -- вызвать прерывание, x = 3 -- вывалиться в отладчик.
- `nop` -- ничего не делает
- `ud2` -- команда, которая гарантированно отсутсвует.

## Best practice

### модуль числа
```asm
  test  eax, eax
  jns   L1
  neg   eax
L1:

% но лучше так:
  cdq
  xor   eax, edx
  sub   eax, edx
```

### Деление 8
```asm
  cdq
  shr   edx, 29
  add   eax, edx
  sar   eax, 3
```

### условные переходы

```c
if(eax == 5 && ebx < 3) {
  X
} else {
  Y
}
```

```asm
  cmp   eax, 5
  jne   LE
  cmp   ebx, 3
  jnb   LE
  X
  jmp   LX
LE:
  Y
LX:
```

### Циклы

#### do-while
```c
do ... while(eax != 0);
```
Некоторые конструкции языков C/C++ существуют именно в таком виде, потому что так их можно эффективно реализовать.
```asm
L1:
  ...
  test  eax
  jnz   L1
```

#### while-do
```c
while(eax != 0) ...
```
```asm
  jz    L2
L1:
  ...
  cmp   eax, 0
  jnz   L1
L2:
```
#### switch
```c
switch (eax) {
  case 1:
    X
    break;
  case 3:
  case 4: Y
  case 6: Z
}
```

```asm
    cmp     eax, 6
    ja      LE
    jmp     dword [eax*4 + table]
L1:
    X
    jmp     LE
L2:
    Y
L3:
    Z
LE:
...
    section  rdata
    table  dd LE, L1, LE, L2, L2, L3
```

### Умножение на 10

```
    lea     eax, [eax*4 + eax]
    add     eax, eax
```

### Деление через умножение

TODO


## секции памяти

- text -- код.
- data -- данные.
- rdata -- данные только для чтения.
- bss -- неиницализированные данные. Почти не занимаю место в исполняемом файле.

Эти секции описывают свойства процесса. Не путать с сегментами! Там кучи, стеки и т. д.

NB) Процесс -- данные, Поток -- вычисления.



## Calling convention:

При написание высокоуровнего кода мы этого почти не замечаем. Но если мы хотим написать код на ассемблере и вызвать его где-то еще, то важно знать как буду вызвать наш код, и как вызвать чужой код. Для этого существуют соглашения (которые можно подкрутить компиляторозависимыми ключами)

|                              | cdecl              | stdcall      | pascal       | fastcall     |
| ---------------------------- | ------------------ | ------------ | ------------ | ------------ |
| Куда класть аргументы?       | stack              | stack        | stack        | reg\stack    |
| Порядок загрузки аргументов? | c, b, a            | c, b, a      | a, b, c      | ?            |
| Кто снимает аргументы?       | caller             | calling      | calling      | ?            |
| Где возвращается заначение?  | edx:eax/eax/ax     | :arrow_left: | :arrow_left: | :arrow_left: |
| Сохраняемые регистры         | ebx, ebp, esi, edi | :arrow_left: | :arrow_left: |              |

**Замечание:** Кто выделяет память под возвращаемое значение, если оно не лезет? Только вызывающий, так как память нужно освобождать ровно так, как выделялась.

**Замечание:** Сохранять все регистры, также как и не сохранять ничего -- дорого.

### Как возвращается большие объекты?

Компилятор генерирет специальный код: выделяет необходимое количество памяти под возвращаемое значение и передает его адрес в качестве нулевого аргумента. 

**TODO:** То есть происходит декорирование функции? Скорее всего нет.

### thiscall

Это нужно для методов классов. Тут тоже пытаются класть `this` в нулевой аргумент. И поэтому порядок `this` и `*result`, если оба необходимо передаавать в аргументах, является implementation behavior.

### Примеры

`printf("%s", p) // cdecl`
```asm
    push  p
    push  fstr
    call  printf
    add   esp, 8
```
`int f(int a, int b) {return a*2 + b;} // cdecl`
```asm
    mov   eax, [esp + 4]
    add   eax, eax
    add   eax, [eax + 8]
    ret
```

### cdecl vs stdcall

В stdcall не возможно написать printf, так как это vararg-функция. Такие функции требуют:
* обратного порядка аргуметов
* стек должен чистить caller, так как функция не может знать сколько аргументов ей передали.

### Best practice
* Конвенция вызова должна совпадать с конфенцией фукнции. Но это неважно для локальных фукнций, которые никто не будет вызвать, кроме вас.

* если мы хотим, например, помнять логику программы и делаем `push` в середине кода, то все адреса, к которым обращаются ниже нужно изменить, так как стек сдвинулся. Поэтому удобно писать адрес из двух часте: `mov eax, [esp + 4 + 4]`, первая цифра -- номер аргумента, вторая -- сколько мы пушнули.

* Агнер Calling convention

## FPU/x87

Исторически это сопросцессор, который был сильно разнесен с CPU. Поэтому нет прямого доступа между их регистрами, только через память.

У сопроцессора есть свои регистры, которые собраны в зацикленный стек.
* `st[0..8]`
  * 80 бит
  * extended presion
  * Поддерживает разные типы:
    * dword(одинарная точность), qword(двойная точность), tbyte(extended точность), BCD80(что-то с десятичной арифметикой).

### Обзор команд

#### Загрузка
- `fld` (from float)
- `fild` (from int)
- `fbld` (bcd80)
- `fldpi`/`fld1`/`fldz` (load pi/1/0)

#### Выгрузка
- `fst` (first store)
- `fstp` (fist store and pop)

Призагрузке и pop стек крутиться и номера регистров меняются. Но при этом мы не можем затирать значения регистров, которые не освободили. Если это не соблюсти будет NaN.

#### Арифметические
- `fprem` -- ищет остаток вычитанием, но не более 64 раз, после просто возвращает результат.
- `fabs`, `fchs`, `fsqrt`, `fsin`, `fcos`, `fsincos` (ищет оба и кладет на стек.)
- `fcom` -- сравнение и запись во флаги сопроцессора, поэтому нельзя делать бранчи с этой командой
- `fcomi` -- сравнение + запись в CF, ZF. **OF не записывается! jne -- не работает**

#### Другие
- `finit` - помечает все регистры как доступные и устанавливает дефолтное значение. 
- fchx st1` (swap st1, st0)
- [command] + ..r = [command with reverse order of argument]
- `ffree` -- освободить регистр.
- `fincstp`/`fdecstp` -- покрутить стек.
- `fisttp` -- TODO

### Calling convention
- Вызванная функция должна зачистить стек командой `finit`
- Вызвращаемое значение на вершине стека(st0). Это верно для любой конвенции, когда функция возврашает вещественное значение.

### Best practice

- про конвертацию между целыми и вещественными числами: (касается не только x87)
  - Долго конвертировать uint в float, так как надо сделать проверки переполнения.
  - Долго конвертировать float в int, так как не совпадают стандартные округления: в C к 0, в asm к ближащему четному (default). Поэтому нужно переключить режим окргуления, а это долго.
  - Лучше не использовать ассемблерные вставки, так как это не переносимо: из-за компиляторазависимиого синтаксиса, а также msvc вообще не поддерживает их под 64bit. Поэтому лучше писать на ассемблере отдельные функции в отдельных файлах. 

==NB)== Как вызвыть функцию на asm, из кода C/C++:

```c++
// C
float __cdecl arctan(float x, int n); // declaration
// C++ 
extern "C" // for name mangling
float __cdecl arctan(float x, int n;) 
```

## SIMD-команды

`SIMD` -- single instruction, multiple data. Это идея когда мы можем одной командой обрабатывать сразу несколько ячеек данных.

### История расширений Intel для SIMD и не только. TODO

- MMX (Pentium MMX) : `mm0..7` - 64 бита мантисы регистров FPU, можно использовать для int. И обрабатывать сразу два int одной командой
- SSE (Pentium III) : `xmm0..7` - 128 битые регистрые, которые можно использовать как 4 float. Плюс, что это никак не связано с FPU, про который пытаются забыть.
- SSE2 (Pentium 4) : можно использовать `xmm` для int.
- SSE3 (later Pentium 4) : доп. команды.
- SSE4 (early Core 2) : доп. горизонтальные команды.
- SSE4.1 (later Core 2, 2013)
- SSE4.2 
- SEE4a
- AVX (2011) : `ymm` - 256 битные регистры, но только для float
- AVX2 (2013) : можно использовать `ymm` для int
- AVX512  (сейчас почти нет) : `zmm` - 512 битные регистры
- FMA (2007-2010) : fased multiply-add, инструкции типа `a*b + c` для `x\ymm` 
- AES_NI (2008) : Advanced Encryption Standard New Instruction 
- BMI : bit manipulation instruction, добавились команды для некоторых логических выражений типа: `~x & x`, `-x & x`, `x & (x - 1)`. Плохо поддерживается, есть только в Haswell.

### MMX

Так как эти регистры накладываются на регистры x87, их нельзя использовать одновременно. Во время работы с `mmx`, все `st` помечаются как недоступные, и в конце нужно вызвать команду `emms`, которая пометит все `st0..8`, как доступные к использованию.

**Замечание**:  Эта команда сильно похожа на `finit`, но последнаяя также устанавливает дефолтное значение.

### Обзор Комнад

- `punpckl{bw, dq, qdq, wd}` - unpack low data. `{bw}` - собирает word из byte, используя младшую часть регистов.  [Схема](https://www.felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html#description)

- `punpckm{bw, dq, qdq, wd}` - unpack high data. `{bw}` - собирает word из byte, используя старшую часть регистров. [Схема](https://www.felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html#description) 

- `packss{wd, dw}` - pack with signed saturation. Saturation - число конвертиться в число меньшей битности, так чтобы значение было ближе всего к исходному.  [Схема](https://www.felixcloutier.com/x86/PACKSSWB:PACKSSDW.html#description)

- `packus{wd, dw}` - pack with unsigned saturation. 

- `pmulhw` - multiply packed signed integer and store high result.

- `pmullw` - multiply packed signed integer and store low result.

-  `pmaddwd` - multiply and add packed integer. [Схема](https://www.felixcloutier.com/x86/PMADDWD.html#description)

- `pcmpeq{b, w, d}` - Compare packed data for equal.

- `pcmpgt{b, w, d}` - Compare packed signed Integer for greater than

- `pand/por/pxor/pandn` - bitwise and/or/xor/and not

- `psrl{w, d, q}` - Shift packed data right logical [Схема](https://www.felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html#description)

- `psra{w, d, q}` - Shift packed data right arithmetic [Схема](https://www.felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html#description)

- `psll{w, d, q}` - Shift packed data left logical. [Схема](https://www.felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html#description)

- `paddus{b, w}` - add packed usigned intgers with unsigned saturation.

- `psubus{b, w}` - sub packed usigned intgers with unsigned saturation.

- `palignr dst, src, imm8` - конкатенирует `dst` и `src`, потом сдавигает в право imm8 байт и записывает младщую часть в `dst`.

- `pshufw dst src imm8` - Shuffle the words in src based on the enocoding in imm8 and store the result in imm1. [Схема](https://www.felixcloutier.com/x86/PSHUFW.html#operation)

- `emms` - Очищает все x87 регистры

- `movq/movd` -- загрузить qword/dword

## Выравнивание

### Как сделать выравнивание данных в asm?

- на стеке

```asm
	section .data
	align 16
	const1: 12 
```

- в куче
  - `alloc` + ручное выравнивание
  - `align_alloc`(Linux)/`virtual_alloc`(Windows)

### Выравнивание стека

В 32 битах жилательно выравнивать стек до 16, а в 64 битности - это обязательно.

### Выделить n байт с выраниванием 16

```asm
	push 	ebp
	mov		ebp, esp
	sub		esp, n
	and 	esp, -16
	...
	mov		esp, ebp
	pop		ebp
```

### Выравнивае по конвенции вызовов

```C
Какой-то пример.
```

## История про разгон кода

TODO

## Режимы работы процессора

**Замечание** Почему важна обратная совместимость? Потому, что старый код очень долго переписывать, и новые технологии внедряются не мнговенно. При этом программная эмуляция очень сильно проседает по скорости.

Режим работы меняет коды команд.

- real 16
- protected 16/32/v86
- long mod 64/compatibility32/compatibility16

### Real mode
Изначально в этом режиме работали 16 битные процессоры.

#### Адресация

В i80186 можно адресовать 1 Мб оперативки, то есть $2^{20}$

`Физический адрес` = `сегмент` * 16 + `смещение(виртуальный адрес)`

Сегментный регистры: `cs`(code), `ds`(data), `ss`(stack), `es`(extra). Они тоже состоят из 16 бит и могут хратить любой адрес.

Сегмент можно указывать явно,

```asm
mov al, [ebx] ; по-умолчанию

mov al, ds:[ebx]

ds: ; seg ds
mov al, [ebx]
```

а может выводиться по-умолчанию: 

- команды, которые работают со стеком(pop, push) используют `ss`
- для адреса команд аналогично `cs`
- для памяти: `bp`, `ebp`, `esp` => `ss` (`sp` нет, потому, что его не бывает в квадратным скобках.)
- Остальные к `ds`.
- В некоторых командах есть свои умолчания.

**Замечание**

```asm
mov al, [ebx + ebp] ; implementation undefined behavior

mov al, [ebx + ebp*1] ; хороший компилятор (not nasm) позволяет таким образом подавить использование ebp как базы
```
**Замечание**
В "C" есть поэтому поводу оговорка, что объект не может занимать больше места чем максимальный размер смещения. (< 64kb)

#### i80286

Может адресовать 24-битные адреса.

Добавились новые сегментные регистры: `fs`, `gs` с неопределенным использованием. 

**A20 line:** в i80186 при обращении за границы 1 Мб происходило переполнение. То есть всегда использовались только последние 20 бит.
А в i80286 можно адресовать большую память, поэтому переполения не происходило и можно было адресовать $2^{20} + 2^{16} - 2^{4}$ в `real mode`. Для обратной совместимости можно влючить переполнение. Про это `Bios Line 20 disable`

#### Проблемы

- Нельзя управлять памятью.

### Protected mode 16

Это режим появился в 286.

Теперь сегментный регистр содержит не базу сегмента, а селектор, который состоит из 3 частей.

```
[0..1] <- RPL
[2] <- G/L
[3..15] <- index
```

- index - индекс дескриптора сегмента в глобальной таблице.

- g/l - global/local description table, но локальные не используется.

- rpl - права
    - 0 - макс. права
    - 3 - мин. права

Дескриптор сегмента состоит из 8 байт и содержит все необходимую информацию о сегменте:
- Базу
- Лимит
- Флаги
- Уровень привелегий.

Адрес таблицы дескрипторов храниться в регистре gdtr (global discription table register).

**Замечание** Для ускорения обращения у сегментного регистра есть теневая часть, в которую загружается дескриптор. Это имеет некоторые последствия.

#### Права

Теперь у нас есть 4 уровня прав. 0 - уровень ОС. 3 - уровень пользователя.

Это позволяет:
- Разграничить пользовательский код и код ОС.
- Ограничить доступ пользователя к данным.

*CPL - current privilege level* - уровень прав в регистре `cs`. Он пределяет права кода. В этом отличие пользовательского кода, от кода OC.

*RPL - request privilege level* - уровень прав в остальных сегментных регистрах, который определяет права для запроса на использование своего дескриптора.

*DPL - descriptor privilege level* - уровень прав в дескрипторе сегмента.
- Если это сегмент кода, то это уровень привелегий это кода.
- Если это сегмент данных, то уровеьн привелегий определяет, кто может обращаться к этим данным.

**Замечаение** Зачем нужен RPL, если есть DPL? 
Когда мы передаем управление более привелегированному коду и просим его, например, изменить данные сегмента, на который у нас прав нет. Тогда вызваемая функция может записать в RPL селектора, записать наш cpl. Так как при обращении к данным проверается не только значание DPL, но и RPL, данные будут защищены. 

Существуют инструкции в защищенном режиме можно использовать только при нулевом CPL.

Процесс может понизить свои права. Но как повысить?    
Мы можем вызвать прерывание, у которого выше уровень привилегий. И он может вернуть нам права.

#### Адресация

Защита достикается повышением абстракции. Теперь адреса бывают:
- логические(logical) - пара <сегмент>:<смещение>
- линейные(linear) - промежуточный уровень(нужен для страничной адресации) = <сегмент> + <смещение>
- физические(physical) - адрес, который подается в шину. <физческий адрес> = <линейный> (пока нет страничной адресации)

В 286 база сегмента составляла 24 бита, поэтому максимальная доступная память - $2^24$ = 16 Mb. При этом длина сегмента менялась от 1 до $2^16$ байт.

#### Переходы:
- Ближние jump, call -- в приделах одного сегмента памяти.
- Дальние: far_jump, far_call -- меняет также сегмент.

### Flat-модель памяти.

Это идея обращения процесса с памятью. Она заключается в том, что память для процесса - это единое и не делимое простраство.

### 32bit защищенный режим

Это режим появился в 386. В нем увеличелась битность линейного адереса до 32 бит и появилась возможность делать сегменты с лимитом 4Gb. Это открыло доступ к Flat-module работы с памятью.

**Замечание**
Выбор режима зависит от размера загруженного дескриптора CS.

### Unreal mode
Существует незадокументированная фича, что при переходе в `real mode` теневая часть не меняется. Это дает доступ к сегментам большого размера в рельном режиме. Это называют нераельном режимом. (unreal mode) **TODO**

### v86
**Подрежим защищенного**
Адресация как в реальном режиме, но с кольцами прав.


![](drawing.svg)
Биос работает в реальном режиме. И дальше постпенно переходит в нормальный режим работы.

### SMM
Режим

------------
`QUESTION` Зачем выравнивать стек перед вызовом?
- Требование некоторых систем в 32бита и соглашение в 64битом мире везде.

`QUESTION` Локальные метки:
- Можно использовать, но это компиляторозависимо.
- Макросы тоже зависят от компилятора.

--------

### Адресация в 64битом мире
(Про страничную адресацию)

От сегментной адресации не осталось почти ничего.
Кроме:
- в `cs` осталось кольцо прав
- в дескрипторе `cs` указывается битность сегмента, которая определяет битность режима.

Остальные сегменты получили базу `0`, и лимит максимальный

#### Как работает 32битная программа на 64 битной винде
- Program System 32 $\rightarrow$ 64bit libs
- Wow 64 --> 32bit libs (они подключаются к программе, но ядро остается 64 битным)

> То есть режим остается 64 битный режим?

Не совсем.
Все это **long mode**. 32/64 - это подрежим.
Когда 32битный код вызывает систему. Вызывается NTDLL32.dll, который делает far_call, к NTDLL64 (64 битному коду систему).
И все это в рамках одного процесса, то есть можно иметь в рамках одного процесса разную битность. Вернее так есть. При чем не обязательно все идет через ядро.

> Почему лучше делать однородную битность?

Потому, что так проще. Иначе надо понимать как это работает.

> Как в linux?

Не знаю

--------

Что с `fc`, `gc`? -- от них осталось поле базы.
- `fc` -- обычно используется для thread local storage
    - Пример: winapp и может показать последнюю ошибку last_error(), но это работает и при нескольких тредов. Потому, что они хранятся локально для каждого треда.
    - `fc` указывает к каждом треде на разное смещение в TEB(thread env block), из который уже узнается настоящий адрес переменной.

`NB` -- Linux используется для тех же целей `gc`
`NB` -- В Win32 -- TEB32, Win64 -- TEB64. Поэтому там используется и `gc`(64), и `fc`(32).

### Страничная адресация
`QUESTION` Почему на некоторых Win32 нельзя выделить больше 4 ГБ

Это лишь лицензионное ограничение. На самом деле благодаря страничной адресации мы можем выделять довольно большое адресное пространство для программы. Так как система сама строит адресное пространство.

`AWE` -- хак, который позволяет выделять процессу больше чем 4ГБ.

- `virtual address` - адреса в программе
- `linear address/logic address` - виртуальные/сегментный адрес + смещение. (На уровне MMU)
    - При страничной адресации происходит еще одно превращение. (Это делает Ось)
- `physical address` - целевой адрес в памяти.

Страница имеет размер `4kb`, поэтому последние 12 байт не участвуют в трансляции.
Страница описывается структурой в 4 байта(Page Table), поэтому в одной странице может лежать 2^10 структур, и это еще один уровень трансляции.
Page directory -- структура, которая хранит адреса этих страниц с структурами (page table).

- `[31..22, 21..12, 11..0] = [10, 10, 12]`
    - Первые 10 -- индекс в page directory, адрес, которой хранится в `cr3`.
    - Вторые 10 -- индекс в page table, адрес, который мы нашли в page directory.
    - Последние 12 -- cмещение в page

`NB`) Традиционно первые сколько-то адресов не замапленые в никуда, это сделано, чтобы null-pointer падал гарантированно. Он просто идет в page directory и там написано, что не замапалено.

У каждого процесса своя иерархия, у каждого есть своя ссылка на свою page directory.

**Feature**:
- Разделяемые библиотеки. Разные процессы мапят одну и ту же память, которая содержит библиотеку. Каждый процесс мапит в свой виртуальные адрес. Эта память находиться в read-only. Если вдруг кто-то захочет поменять код библиотеки, то случается page_fault. Потом процессор копирует нужные страницы и ставит write permission. То есть в режиме copy-on-write.
- swap(paging): swap -- выгрузка всего дампа (сейчас редкость), paging -- выгрузка части. Сброс страниц оперативки в память. Если страница долго не используется, то ОС выгружает ее, если мы хотим обратиться к ней, то она вгружается.

`NB`) Бывает спекулятивное подгрузка страниц. Можно посмотреть на Аиде, которая может вырубать это на работающем процессе.

Как операционка понимает, что можно выгрузить? в page table and page directory, в смещении хранит разные бит флагов: чтение/запись, грязность. Сначала ось проставляет все страницы чистые, потом те

Что делать если у нас оперативки больше, чем 4КБ?
**Расширения:**
- PSE: большие страницы. Достигается флагами.
- PAE: Мы делаем структуру, которая описывает страницу жирнее, чтобы адресовать больше адресов. Из-за этого меньше table, поэтому есть еще один уровень. `[31..30, 29..21, 20..12, 11..0] = [2, 9, 9, 12]`
    - Это позволяет разбрасывать больше физической оперативки.

Адресное пространство делиться на системное и несистемное. Это определяет по первому биту.
Для 32 битных адресов: младшие 2ГБ -- userspace, старшие 2ГБ -- kernelspace.

`NB`) Поэтому для 32битных приложений все равно полезно 64битная операционка, так тогда оно получит не 2ГБ, а 4ГБ.

**x32** -- подсистема linux, которая позволяет работать в 64битном мире, но указатели размером 32бита. Иногда это полезно. Так тогда мы получаем полезности 64битного режима, но не платим за это размером указателей.

`NB`) Есть две таблицы:
    - таблица, для всего, ее используется система.
    - урезанная таблица, для процесса.
При syscall, мы переходим в код ядра, с полными таблицами.
