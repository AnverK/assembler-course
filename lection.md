# Режимы работы процессора

## Real mod
- 16 битный процессор
    - У него могло быть 1 мб оперативки( с помощью регистров)
    - Адрес всегда состоит из seg:off
        - сегмент может вычисляться автоматически из регистра сегмента
            - cs (code), ds (data), ss(stack), es(extra).
            - fs, gs -- добавились позже (в 286)
    - 286 процессор вычислял физ. адрес = seg * 16 + off
        - Это было сделано, чтобы используя 16битные регистры можно использовать для 20битных адресов.
        - В "C" есть поэтому поводу оговорка, что объект не может занимать больше места чем максимальный размер смещения. (< 64kb)
        - Есть много способов сослаться на один адрес
        - Что будет если мы вывезем из диапазона? (мы можем выйти на 65519)
            - Как это работает? Проц. просто берет первые 20 бит.
            - Bios Line 20 disable -- опция биоса, которая позволяет включить эту фичу, для обратной совместимости.
- **Проблема: безопасность**
    - Любая программа имеет доступ ко всему. Поэтому появился защищенный режим работы

## Защищенный режим
Начиная с 286 было выделено 4 кольца.
- 0 - макс. права
- 3 - мин. права

На что влияют права?
- Как можно менять права.
- Что можно читать из оперативки.

Теперь сегментный регистр -- это что-то из 3 частей

0-1| 2  | 3-15
---|----|-----
RPL|G/L |index

- index -- индекс дескриптора сегмента
- g/l -- global/local description table, но локальные не используется.
    - gdtr -- регистр, который указывает на адрес таблицы.
- rpl -- права

Сегмент теперь устроен сложнее, вся информация написана в дескрипторе
- База сегмента (то, что было раньше в регистре сегмента)

Сегментный регистр имеет теневую часть, куда он загружает сегментный дескриптор.

внутри cs, rpl -- называется CPL -- current privilege level
Мы можем понизить свои права.
Но как повысить? Мы можем вызвать прерывание, у которого может быть выше уровень привилегий. И он может вернуть нам права.

**NB)** не путать сегмент с секцией. Секция -- это уровень операционной системы.

- В 32bit
    - Здесь у нас, так называемая Flat-module памяти. Когда у нас все базы сегментов равны 0 и лимит 4Kb

Переходы:
- Ближние jump, call -- в приделах одного сегмента памяти.
- Дальние: far_jump, far_call -- меняет также сегмент.

**Зачем сегменты**
- Управление правами

**Как определяются права?**
- CPL
- RPL
- права, которые написаны в дескрипторе.

**Как написать обращение с указанием сегмента?**
```
mov al, [ebx] ; по-умолчанию

mov al, ds:[ebx]

ds: / seg ds
mov al, [ebx]
```
**по-умолчанию:**
- если мы обращаемся к стеку, то там ss по-умолчанию
- для команд аналогично cs
- для памяти: bp, ebp, esp => ss (sp нет, потому, что его не бывает в кв. скобках.)
- В некоторых командах есть свои умолчания. Например, movvc
- Остальные к ds

**Замечание**
```
mov al, [ebx + ebp] ; implementation undefined behavior

mov al, [ebx + ebp*1] ; хороший компилятор (not nasm) позволяет таким образом, подавить использование ebp как базы
```

## 32bit защищенный режим
`Выбор режима зависит от размера загруженного дескриптора CS.`

В 32bit мы не можем использовать ax, он интерпретируется как eax.

**Теневая часть сегментного регистра не меняется при изменении режима.**
Поэтому существует нереальный режим работы.

**Кто пишет под реальный режим?**
Почти никто, но биос работает в реальном режиме. И с этим приходить считаться.

## v86
**Подрежим защищенного**
Который адресуется как в реальном режиме. Но с правами 3 кольца.

| | | |
----------|---------|---------------|
reset     |         |  CR0.PE = 1   |
`------>` | real 16 | `<---------`  | protected 16/32, v86 16
          |         | `--------->`  |
          |         | CR0.PE = 0    |

## SMM
Режим

------------
`QUESTION` Зачем выравнивать стек перед вызовом?
- Требование некоторых систем в 32бита и соглашение в 64битом мире везде.

`QUESTION` Локальные метки:
- Можно использовать, но это компиляторозависимо.
- Макросы тоже зависят от компилятора.
--------

## Адресация в 64битом мире
(Про страничную адресацию)

От сегментной адресации не осталось почти ничего.
Кроме:
- в `cs` осталось кольцо прав
- в дескрипторе `cs` указывается битность сегмента, которая определяет битность режима.

Остальные сегменты получили базу `0`, и лимит максимальный

### Как работает 32битная программа на 64 битной винде
- Program System 32 --> 64bit libs
- Wow 64 --> 32bit libs (они подключаются к программе, но ядро остается 64 битным)

> То есть режим остается 64 битный режим?

Не совсем.
Все это long mode. 32/64 - это подрежим.
Когда 32битный код вызывает систему. Вызывается NTDLL32.dll, который делает far_call, к NTDLL64 (64 битному коду систему).
И все это в рамках одного процесса, то есть можно иметь в рамках одного процесса разную битность. Вернее так есть. При чем не обязательно все идет через ядро.

> Почему лучше делать однородную битность?

Потому, что так проще. Иначе надо понимать как это работает.

> Как в linux?

Не знаю

--------

Что с `fc`, `gc`? -- от них осталось поле базы.
- `fc` -- обычно используется для thread local storage
    - Пример: winapp и может показать последнюю ошибку last_error(), но это работает и при нескольких тредов. Потому, что они хранятся локально для каждого треда.
    - `fc` указывает к каждом треде на разное смещение в TEB(thread env block), из который уже узнается настоящий адрес переменной.

`NB` -- Linux используется для тех же целей `gc`
`NB` -- В Win32 -- TEB32, Win64 -- TEB64. Поэтому там используется и `gc`(64), и `fc`(32).

## Страничная адресация
`QUESTION` Почему на некоторых Win32 нельзя выделить больше 4 ГБ

Это лишь лицензионное ограничение. На самом деле благодаря страничной адресации мы можем выделять довольно большое адресное пространство для программы. Так как система сама строит адресное пространство.

`AWE` -- хак, который позволяет выделять процессу больше чем 4ГБ.
