# Режимы работы процессора

## Real mod
- 16 битный процессор
    - У него могло быть 1 мб оперативки( с помощью регистров)
    - Адрес всегда состоит из seg:off
        - сегмент может вычисляться автоматически из регистра сегмента
            - cs (code), ds (data), ss(stack), es(extra).
            - fs, gs -- добавились позже (в 286)
    - 286 процессор вычислял физ. адрес = seg * 16 + off
        - Это было сделано, чтобы используя 16битные регистры можно использовать для 20битных адресов.
        - В "C" есть поэтому поводу оговорка, что объект не может занимать больше места чем максимальный размер смещения. (< 64kb)
        - Есть много способов сослаться на один адрес
        - Что будет если мы вывезем из диапазона? (мы можем выйти на 65519)
            - Как это работает? Проц. просто берет первые 20 бит.
            - Bios Line 20 disable -- опция биоса, которая позволяет включить эту фичу, для обратной совместимости.
- **Проблема: безопасность**
    - Любая программа имеет доступ ко всему. Поэтому появился защищенный режим работы

## Защищенный режим
Начиная с 286 было выделено 4 кольца.
- 0 - макс. права
- 3 - мин. права

На что влияют права?
- Как можно менять права.
- Что можно читать из оперативки.

Теперь сегментный регистр -- это что-то из 3 частей

0-1| 2  | 3-15
---|----|-----
RPL|G/L |index

- index -- индекс дескриптора сегмента
- g/l -- global/local description table, но локальные не используется.
    - gdtr -- регистр, который указывает на адрес таблицы.
- rpl -- права

Сегмент теперь устроен сложнее, вся информация написана в дескрипторе
- База сегмента (то, что было раньше в регистре сегмента)

Сегментный регистр имеет теневую часть, куда он загружает сегментный дескриптор.

внутри cs, rpl -- называется CPL -- current privilege level
Мы можем понизить свои права.
Но как повысить? Мы можем вызвать прерывание, у которого может быть выше уровень привилегий. И он может вернуть нам права.

**NB)** не путать сегмент с секцией. Секция -- это уровень операционной системы.

- В 32bit
    - Здесь у нас, так называемая Flat-module памяти. Когда у нас все базы сегментов равны 0 и лимит 4Kb

Переходы:
- Ближние jump, call -- в приделах одного сегмента памяти.
- Дальние: far_jump, far_call -- меняет также сегмент.

**Зачем сегменты**
- Управление правами

**Как определяются права?**
- CPL
- RPL
- права, которые написаны в дескрипторе.

**Как написать обращение с указанием сегмента?**
```
mov al, [ebx] ; по-умолчанию

mov al, ds:[ebx]

ds: / seg ds
mov al, [ebx]
```
**по-умолчанию:**
- если мы обращаемся к стеку, то там ss по-умолчанию
- для команд аналогично cs
- для памяти: bp, ebp, esp => ss (sp нет, потому, что его не бывает в кв. скобках.)
- В некоторых командах есть свои умолчания. Например, movvc
- Остальные к ds

**Замечание**
```
mov al, [ebx + ebp] ; implementation undefined behavior

mov al, [ebx + ebp*1] ; хороший компилятор (not nasm) позволяет таким образом, подавить использование ebp как базы
```

## 32bit защищенный режим
`Выбор режима зависит от размера загруженного дескриптора CS.`

В 32bit мы не можем использовать ax, он интерпретируется как eax.

**Теневая часть сегментного регистра не меняется при изменении режима.**
Поэтому существует нереальный режим работы.

**Кто пишет под реальный режим?**
Почти никто, но биос работает в реальном режиме. И с этим приходить считаться.

## v86
**Подрежим защищенного**
Который адресуется как в реальном режиме. Но с правами 3 кольца.

| | | |
----------|---------|---------------|
reset     |         |  CR0.PE = 1   |
`------>` | real 16 | `<---------`  | protected 16/32, v86 16
          |         | `--------->`  |
          |         | CR0.PE = 0    |

## SMM
Режим

------------
`QUESTION` Зачем выравнивать стек перед вызовом?
- Требование некоторых систем в 32бита и соглашение в 64битом мире везде.

`QUESTION` Локальные метки:
- Можно использовать, но это компиляторозависимо.
- Макросы тоже зависят от компилятора.
--------

## Адресация в 64битом мире
(Про страничную адресацию)

От сегментной адресации не осталось почти ничего.
Кроме:
- в `cs` осталось кольцо прав
- в дескрипторе `cs` указывается битность сегмента, которая определяет битность режима.

Остальные сегменты получили базу `0`, и лимит максимальный

### Как работает 32битная программа на 64 битной винде
- Program System 32 --> 64bit libs
- Wow 64 --> 32bit libs (они подключаются к программе, но ядро остается 64 битным)

> То есть режим остается 64 битный режим?

Не совсем.
Все это **long mode**. 32/64 - это подрежим.
Когда 32битный код вызывает систему. Вызывается NTDLL32.dll, который делает far_call, к NTDLL64 (64 битному коду систему).
И все это в рамках одного процесса, то есть можно иметь в рамках одного процесса разную битность. Вернее так есть. При чем не обязательно все идет через ядро.

> Почему лучше делать однородную битность?

Потому, что так проще. Иначе надо понимать как это работает.

> Как в linux?

Не знаю

--------

Что с `fc`, `gc`? -- от них осталось поле базы.
- `fc` -- обычно используется для thread local storage
    - Пример: winapp и может показать последнюю ошибку last_error(), но это работает и при нескольких тредов. Потому, что они хранятся локально для каждого треда.
    - `fc` указывает к каждом треде на разное смещение в TEB(thread env block), из который уже узнается настоящий адрес переменной.

`NB` -- Linux используется для тех же целей `gc`
`NB` -- В Win32 -- TEB32, Win64 -- TEB64. Поэтому там используется и `gc`(64), и `fc`(32).

## Страничная адресация
`QUESTION` Почему на некоторых Win32 нельзя выделить больше 4 ГБ

Это лишь лицензионное ограничение. На самом деле благодаря страничной адресации мы можем выделять довольно большое адресное пространство для программы. Так как система сама строит адресное пространство.

`AWE` -- хак, который позволяет выделять процессу больше чем 4ГБ.

- `virtual address` - адреса в программе
- `linear address/logic address` - виртуальные/сегментный адрес + смещение. (На уровне MMU)
    - При страничной адресации происходит еще одно превращение. (Это делает Ось)
- `physical address` - целевой адрес в памяти.

Страница имеет размер `4kb`, поэтому последние 12 байт не участвуют в трансляции.
Страница описывается структурой в 4 байта(Page Table), поэтому в одной странице может лежать 2^10 структур, и это еще один уровень трансляции.
Page directory -- структура, которая хранит адреса этих страниц с структурами (page table).

- `[31..22, 21..12, 11..0] = [10, 10, 12]`
    - Первые 10 -- индекс в page directory, адрес, которой хранится в `cr3`.
    - Вторые 10 -- индекс в page table, адрес, который мы нашли в page directory.
    - Последние 12 -- cмещение в page

`NB`) Традиционно первые сколько-то адресов не замапленые в никуда, это сделано, чтобы null-pointer падал гарантированно. Он просто идет в page directory и там написано, что не замапалено.

У каждого процесса своя иерархия, у каждого есть своя ссылка на свою page directory.

**Feature**:
- Разделяемые библиотеки. Разные процессы мапят одну и ту же память, которая содержит библиотеку. Каждый процесс мапит в свой виртуальные адрес. Эта память находиться в read-only. Если вдруг кто-то захочет поменять код библиотеки, то случается page_fault. Потом процессор копирует нужные страницы и ставит write permission. То есть в режиме copy-on-write.
- swap(paging): swap -- выгрузка всего дампа (сейчас редкость), paging -- выгрузка части. Сброс страниц оперативки в память. Если страница долго не используется, то ОС выгружает ее, если мы хотим обратиться к ней, то она вгружается.

`NB`) Бывает спекулятивное подгрузка страниц. Можно посмотреть на Аиде, которая может вырубать это на работающем процессе.

Как операционка понимает, что можно выгрузить? в page table and page directory, в смещении хранит разные бит флагов: чтение/запись, грязность. Сначала ось проставляет все страницы чистые, потом те

Что делать если у нас оперативки больше, чем 4КБ?
**Расширения:**
- PSE: большие страницы. Достигается флагами.
- PAE: Мы делаем структуру, которая описывает страницу жирнее, чтобы адресовать больше адресов. Из-за этого меньше table, поэтому есть еще один уровень. `[31..30, 29..21, 20..12, 11..0] = [2, 9, 9, 12]`
    - Это позволяет разбрасывать больше физической оперативки.

Адресное пространство делиться на системное и несистемное. Это определяет по первому биту.
Для 32 битных адресов: младшие 2ГБ -- userspace, старшие 2ГБ -- kernelspace.

`NB`) Поэтому для 32битных приложений все равно полезно 64битная операционка, так тогда оно получит не 2ГБ, а 4ГБ.

**x32** -- подсистема linux, которая позволяет работать в 64битном мире, но указатели размером 32бита. Иногда это полезно. Так тогда мы получаем полезности 64битного режима, но не платим за это размером указателей.

`NB`) Есть две таблицы:
    - таблица, для всего, ее используется система.
    - урезанная таблица, для процесса.
При syscall, мы переходим в код ядра, с полными таблицами.
