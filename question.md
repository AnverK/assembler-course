## Вопросы по теме и не очень.
### Как вызвать linux 64 код на windows, где только fascall64?

Не понятно как.

### Зачем в момент вызова call нужно выравнивать стек?

Нужно потому, что иначе все **должно** упасть по конвенции.

#### Почему так принято в ковенции? 
- что-то про удобство вывравнивания SEE
- что-то про совместимость

### Почему на стек лучше класть данные не меньшей битности, чем код.

Потому, что в CPU есть специальные оптимзации для работы со стеком.

**TODO: проверить эффект**

### Правда ли, что GPU отличается от CPU только тем, что SIMD длиннее?
Не совсем, так. В GPU не SIMD, а SIMT (singled instruction, multiple thread (not data)).  Хотя это очень похоже.

### Почему может не работать вызов printf с помощью `syscall` в asm-файле для float?

Тут есть особенность языка C: printf всегда неявно конвертирует float в double. Он их нигде не различает.

### Что такое writemask для `movss`

Это расширение AVX+. Его почти нигде нет.

### Полностью ли сохраняется ли соместимость с прошлыми процессорами?

Начиная с 32битных - 100%.
А с 8086 могут быть отличия, хотя бы потому, что тогда были не дочеты в стандартизации. Например, что кладется на стек при `push sp`.

> fat-crocodile: Полной совместимости, конечно, не получилось. Реальный режим Intel386 и следующих поколений процессоров имеет многочисленные, хотя и не очень крупные отличия от 8086.
