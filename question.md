## Вопросы по теме и не очень.
### Как вызвать linux 64 код на windows, где только fascall64?

Не понятно как.

### Зачем в момент вызова call нужно выравнивать стек?

- что-то про удобство вывравнивания SEE
- что-то про совместимость

## Вопросы к Скакову

- Как работает режим совместимости в 64 битах.
- Желательно поддерживать однородную битность?
- В 32битном режиме использовать e-регистры
- меняется ли SF при беззнаковых операциях.
- ленивость условной загрузки Зачем?
- Зачем делить пространство на системное и несистемное? Если все равно переключается контекст.

## Консультация

- Посмотреть формы `mul`, `div`
- CF/OF -- беззнаковое переполнение/знаковое переполнение.
- Помнить что такое Flat-model
- Просто понимать, что существуют дальние переходы
- функция возвращает большие числа на стеке
- помнить по `emmc` -- очистка
- `movdqa` vs `movabs` -- одно и тоже, но лучше не мешать типы данных при вычислении.
- `rep` повторить команду столько раз сколько написано в rax.
- movsb/sv/sq -- пересылает бит \[edi\] -> \[esi\] и в зависимость от `DF` инкрементируешь в нужную сторону.
- изменить режим -- это привилегированная операция, а изменить подрежим -- не привилегированная операция.
- нужно понимать, что как примерно переключаться в long mod
- Ограничение на количество адресуемой памяти для всей системы 64ГБ. Решение этого -- PAE
- Flat model -- идея когда все сегменты имеют базу 0 и максимальный лимит.
- Повторить историю SSE
- как повысить права: прерывание,

## Вопросы, которые появились летом
- "Лучше не класть на стек данные меньшей битности, чем программа, иначе бьет по скорости."
- Что будет, если сделать сдвиг больше, чем на 32.
- Что просходит, когда возвращается большой объект. Почитать для уточнения.
- В чем разница между `emms` vs `finit`

## Новые вопрсы

### Правда ли, что GPU отличается от CPU только тем, что SIMD длиннее?
Не совсем, так. В GPU не SIMD, а SIMT (singled instruction, multiple thread (not data)).  Хотя это очень похоже.

### Что такое writemask для `movss`

Это расширение AVX+. Его почти нигде нет.

### Почему может не работать вызов printf с помощью `syscall` в asm-файле для float?

Тут есть особенность языка C: printf всегда неявно конвертирует float в double. Он их нигде не различает.

### Что лучше подходит для временных данных stack vs bss-section?

Лучше stack, так как тогда проще рефакторинг asm-кода, нет наложения имен.

### Можно ли использовать макросы?

Можно, но это компиляторозависимо.

### В чем отличия ?

> Полной совместимости, конечно, не получилось. Реальный режим Intel386 и следующих поколений процессоров имеет многочисленные, хотя и не очень крупные отличия от 8086.
> Но, поскольку подробное рассмотрение реального режима выходит за рамки курса, нигде далее эти отличия даже не упоминаются. Кому интересно, идите на http://wasm.ru, ищите там пользователя The Svin и спрашивайте его лично, он всё знает :)
> Большое спасибо ему за это замечание.


------------
`QUESTION` Зачем выравнивать стек перед вызовом?
- Требование некоторых систем в 32бита и соглашение в 64битом мире везде.

`QUESTION` Локальные метки:
- Можно использовать, но это компиляторозависимо.
- Макросы тоже зависят от компилятора.

--------
