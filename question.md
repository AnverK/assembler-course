## Вопросы по теме и не очень.
### Как вызвать linux 64 код на windows, где только fascall64?

Не понятно как.

### Какие адреса кеширует L2, L1 кеши: виртуальные или физический?

Физический

### При переключении процесса, сбрасываются ли кешы физических адресов?
### Зачем сбрасывать что-то кроме TLB?

Не надо, только TLB сбрасываем.

### TLB -- программно или аппаратно?
Аппаратно, но настраивается программно из оси, поэтому ось имеет к ним доступ.

### Как работает 64 бит в страничной адресации?

- У нас больше уровней.
- Больше адрес.
- Больше страницы.

`NB`) Ходят слухи, что можно делать даже странице на 1ГБ. Можно загрузить туда ядро, что очень хорошо кешу.
`NB`) Почитать про canonical address.

## Вопросы вовремя сессии.

- Желательно поддерживать однородную битность?
- В 32битном режиме использовать e-регистры
- меняется ли SF при беззнаковых операциях.
- ленивость условной загрузки
- sssssssssssssssssssssse
- Зачем в момент вызова call нужно выравнивать стек
- Написать таску с `strlen`
- Как передаются много аргументов?
- Что уродского в конвенции this

## Консультация

- BMI, FMA (почитать, что есть такое)
    - FMA -- команды вида a*b + c (смысл в том, что округление происходит только один раз)
        - `NB`это команда, на которой меряют флопсы.
- Нужно знать с SSE2 знать какая архитектура поддерживает
- Посмотреть формы `mul`, `div`
- CF/OF -- беззнаковое переполнение/знаковое переполнение.
- Помнить что такое Flat-model
- Просто понимать, что существуют дальние переходы
- функция возвращает большие числа на стеке
- помнить по `emmc` -- очистка
- `movdqa` vs `movabs` -- одно и тоже, но лучше не мешать типы данных при вычислении.
- `rep` повторить команду столько раз сколько написано в rax.
- movsb/sv/sq -- пересылает бит \[edi\] -> \[esi\] и в зависимость от `DF` инкрементируешь в нужную сторону.
- изменить режим -- это привилегированная операция, а изменить подрежим -- не привилегированная операция.
- нужно понимать, что как примерно переключаться в long mod
- Ограничение на количество адресуемой памяти для всей системы 64ГБ. Решение этого -- PAE
- Flat model -- идея когда все сегменты имеют базу 0 и максимальный лимит.
- Повторить историю SSE
- как повысить права: прерывание,

## Вопросы, которые появились летом
- "Лучше не класть на стек данные меньшей битности, чем программа, иначе бьет по скорости."
- Что будет, если сделать сдвиг больше, чем на 32.
- Что просходит, когда возвращается большой объект. Почитать для уточнения.
- В чем разница между `emms` vs `finit`

## Новые вопрсы

### Правда ли, что GPU отличается от CPU только тем, что SIMD длиннее?
Не совсем, так. В GPU не SIMD, а SIMT (singled instruction, multiple thread (not data)).  Хотя это очень похоже.

### Что такое writemask для `movss`

Это расширение AVX+. Его почти нигде нет.

### Почему может не работать вызов printf с помощью `syscall` в asm-файле для float?

Тут есть особенность языка C: printf всегда неявно конвертирует float в double. Он их нигде не различает.

### Что лучше подходит для временных данных stack vs bss-section?

Лучше stack, так как тогда проще рефакторинг asm-кода, нет наложения имен.

### Можно ли использовать макросы?

Можно, но это компиляторозависимо.

### В чем отличия ?

> Полной совместимости, конечно, не получилось. Реальный режим Intel386 и следующих поколений процессоров имеет многочисленные, хотя и не очень крупные отличия от 8086.
> Но, поскольку подробное рассмотрение реального режима выходит за рамки курса, нигде далее эти отличия даже не упоминаются. Кому интересно, идите на http://wasm.ru, ищите там пользователя The Svin и спрашивайте его лично, он всё знает :)
> Большое спасибо ему за это замечание.


------------
`QUESTION` Зачем выравнивать стек перед вызовом?
- Требование некоторых систем в 32бита и соглашение в 64битом мире везде.

`QUESTION` Локальные метки:
- Можно использовать, но это компиляторозависимо.
- Макросы тоже зависят от компилятора.

--------